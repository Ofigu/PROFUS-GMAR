<!DOCTYPE html>
<html>
<head>
  <title>Trade Coins</title>
  <style>
    /* Set a fixed width and height for the coin images */
    td img {
      width: 40px; /* Adjust the desired width */
      height: 40px; /* Adjust the desired height */
    }
    
    .search-filters {
      display: flex;
      gap: 10px;
    }
  </style>
</head>
<body>
  <h1>Coins List</h1>
  <p>Balance: $<span id="balance">1000.00</span></p>
  
  <div class="search-filters">
    <div>
      <label for="searchInput">Search:</label>
      <input type="text" id="searchInput" oninput="filterCoins()" placeholder="Search by coin name">
    </div>
  
    <div>
      <label for="maxPriceInput">Max Price:</label>
      <input type="number" id="maxPriceInput" oninput="filterCoins()" step="0.01" placeholder="Enter max price">
    </div>
  
    <div>
      <label for="recommendedInput">Recommended:</label>
      <input type="checkbox" id="recommendedInput" onclick="filterCoins()">
    </div>
  
    <div>
      <label for="altCoinInput">Alt Coin:</label>
      <input type="checkbox" id="altCoinInput" onclick="filterCoins()">
    </div>
  
    <div>
      <label for="proofOfWorkInput">Proof of Work:</label>
      <input type="checkbox" id="proofOfWorkInput" onclick="filterCoins()">
    </div>
  </div>
  
  <table>
    <thead>
      <tr>
        <th>Image</th>
        <th>Coin Name</th>
        <th>Price</th>
        <th>Recommended</th>
        <th>Alt Coin</th>
        <th>Proof of Work</th>
        <th></th>
        <th></th>
      </tr>
    </thead>
    <tbody id="coinTableBody">
      <!-- Coins will be dynamically added here -->
    </tbody>
  </table>

  <h2>Purchased Coins</h2>
  <table>
    <thead>
      <tr>
        <th>Coin Name</th>
        <th>Amount</th>
      </tr>
    </thead>
    <tbody id="purchasedCoinsTableBody">
      <!-- Purchased coins will be dynamically added here -->
    </tbody>
  </table>

  <script>
    // Array to store purchased coins
    const purchasedCoins = [];

    // Function to fetch coins from the backend and populate the table
    async function fetchCoins() {
      try {
        const response = await fetch('/coins'); // Replace '/coins' with your actual backend endpoint to retrieve the coin data
        const coins = await response.json();

        // Sort the coins by largest price to lowest
        coins.sort((a, b) => b.Price - a.Price);

        const coinTableBody = document.getElementById('coinTableBody');

        // Iterate over the coins and create table rows dynamically
        coins.forEach((coin) => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td><img src="${coin.ImageOfCoin}" alt="Coin Image"></td>
            <td>${coin.CoinName}</td>
            <td id="${coin._id}Price">${coin.Price}</td>
            <td>${coin.Recommended}</td>
            <td>${coin.AltCoin}</td>
            <td>${coin.ProofOfWork}</td>
            <td>
              <input class="buy-input" type="text" placeholder="Amount">
              <button class="buy-button" onclick="performTrade(this, '${coin._id}', 'buy')">Buy</button>
            </td>
            <td>
              <input class="sell-input" type="text" placeholder="Amount">
              <button class="sell-button" onclick="performTrade(this, '${coin._id}', 'sell')">Sell</button>
            </td>
          `;

          coinTableBody.appendChild(row);
        });
      } catch (error) {
        console.error('Error fetching coins:', error);
      }
    }

    // Function to perform the trade based on the selected action (buy/sell)
    function performTrade(button, coinId, action) {
      const input = action === 'buy' ? button.parentNode.querySelector('.buy-input') : button.parentNode.querySelector('.sell-input');
      const amount = parseFloat(input.value);

      if (!isNaN(amount) && amount > 0) {
        const price = parseFloat(document.getElementById(`${coinId}Price`).innerText);

        if (action === 'buy') {
          buyCoin(coinId, price, amount);
        } else if (action === 'sell') {
          sellCoin(coinId, price, amount);
        }
      }
    }

    // Function to handle the buy action
    function buyCoin(coinId, price, amount) {
      const balanceElement = document.getElementById('balance');
      const balance = parseFloat(balanceElement.innerText);

      const totalPrice = price * amount;

      if (totalPrice <= balance) {
        const newBalance = balance - totalPrice;
        balanceElement.innerText = newBalance.toFixed(2);
        console.log(`Bought ${totalPrice.toFixed(2)} worth of ${coinId}`);

        // Update the purchased coins table
        const purchasedCoinsTableBody = document.getElementById('purchasedCoinsTableBody');
        const existingRow = document.getElementById(`${coinId}Row`);

        if (existingRow) {
          // If the coin already exists in the table, update the amount
          const existingAmount = parseFloat(existingRow.querySelector('.purchased-coin-amount').innerText);
          const newAmount = existingAmount + amount;
          existingRow.querySelector('.purchased-coin-amount').innerText = newAmount.toFixed(2);
        } else {
          // If the coin is being bought for the first time, add a new row
          const newRow = document.createElement('tr');
          newRow.id = `${coinId}Row`;
          newRow.innerHTML = `
            <td>${coinId}</td>
            <td class="purchased-coin-amount">${amount.toFixed(2)}</td>
          `;
          purchasedCoinsTableBody.appendChild(newRow);
        }
      } else {
        alert('Insufficient balance for buying.');
      }
    }

    // Function to handle the sell action
    function sellCoin(coinId, price, amount) {
      const balanceElement = document.getElementById('balance');
      const balance = parseFloat(balanceElement.innerText);

      const totalPrice = price * amount;
      const newBalance = balance + totalPrice;
      balanceElement.innerText = newBalance.toFixed(2);
      console.log(`Sold ${totalPrice.toFixed(2)} worth of ${coinId}`);

      // Update the purchased coins table
      const purchasedCoinsTableBody = document.getElementById('purchasedCoinsTableBody');
      const existingRow = document.getElementById(`${coinId}Row`);

      const existingAmount = parseFloat(existingRow.querySelector('.purchased-coin-amount').innerText);

      if (amount >= existingAmount) {
        // If the entire amount is being sold, remove the row from the table
        purchasedCoinsTableBody.removeChild(existingRow);
      } else {
        // If only a portion of the amount is being sold, update the amount
        const newAmount = existingAmount - amount;
        existingRow.querySelector('.purchased-coin-amount').innerText = newAmount.toFixed(2);
      }
    }

    // Function to filter the coins based on user input
    function filterCoins() {
      const searchInput = document.getElementById('searchInput').value.toLowerCase();
      const maxPriceInput = parseFloat(document.getElementById('maxPriceInput').value);
      const recommendedInput = document.getElementById('recommendedInput').checked;
      const altCoinInput = document.getElementById('altCoinInput').checked;
      const proofOfWorkInput = document.getElementById('proofOfWorkInput').checked;

      const coinRows = document.querySelectorAll('#coinTableBody tr');

      coinRows.forEach((row) => {
        const coinName = row.querySelector('td:nth-child(2)').innerText.toLowerCase();
        const coinPrice = parseFloat(row.querySelector('td:nth-child(3)').innerText);
        const coinRecommended = row.querySelector('td:nth-child(4)').innerText === 'true';
        const coinAltCoin = row.querySelector('td:nth-child(5)').innerText === 'true';
        const coinProofOfWork = row.querySelector('td:nth-child(6)').innerText === 'true';

        const coinMatchesSearch = coinName.includes(searchInput);
        const coinMatchesMaxPrice = isNaN(maxPriceInput) || coinPrice <= maxPriceInput;
        const coinMatchesRecommended = !recommendedInput || coinRecommended;
        const coinMatchesAltCoin = !altCoinInput || coinAltCoin;
        const coinMatchesProofOfWork = !proofOfWorkInput || coinProofOfWork;

        if (coinMatchesSearch && coinMatchesMaxPrice && coinMatchesRecommended && coinMatchesAltCoin && coinMatchesProofOfWork) {
          row.style.display = '';
        } else {
          row.style.display = 'none';
        }
      });
    }

    // Fetch coins when the page loads
    fetchCoins();
  </script>
</body>
</html>
